// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DaemonClient is the client API for Daemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DaemonClient interface {
	LoginUser(ctx context.Context, in *LoginUserRequest, opts ...grpc.CallOption) (*LoginUserResponse, error)
	SignupUser(ctx context.Context, in *SignupUserRequest, opts ...grpc.CallOption) (*LoginUserResponse, error)
	InviteUser(ctx context.Context, in *InviteUserRequest, opts ...grpc.CallOption) (*InviteUserResponse, error)
	ListUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListUsersResponse, error)
	ChangeUserPasswd(ctx context.Context, in *UpdatePasswdRequest, opts ...grpc.CallOption) (*UpdatePasswdResponse, error)
	DestroyUser(ctx context.Context, in *DestroyUserRequest, opts ...grpc.CallOption) (*DestroyUserResponse, error)
	SetTeamSuspend(ctx context.Context, in *SetTeamSuspendRequest, opts ...grpc.CallOption) (*Empty, error)
	UpdateTeamPassword(ctx context.Context, in *UpdateTeamPassRequest, opts ...grpc.CallOption) (*UpdateTeamPassResponse, error)
	GetAPICreds(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CredsResponse, error)
	CreateEvent(ctx context.Context, in *CreateEventRequest, opts ...grpc.CallOption) (Daemon_CreateEventClient, error)
	StopEvent(ctx context.Context, in *StopEventRequest, opts ...grpc.CallOption) (Daemon_StopEventClient, error)
	SuspendEvent(ctx context.Context, in *SuspendEventRequest, opts ...grpc.CallOption) (Daemon_SuspendEventClient, error)
	ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error)
	ListEventTeams(ctx context.Context, in *ListEventTeamsRequest, opts ...grpc.CallOption) (*ListEventTeamsResponse, error)
	RestartTeamLab(ctx context.Context, in *RestartTeamLabRequest, opts ...grpc.CallOption) (Daemon_RestartTeamLabClient, error)
	SolveChallenge(ctx context.Context, in *SolveChallengeRequest, opts ...grpc.CallOption) (*SolveChallengeResponse, error)
	AddChallenge(ctx context.Context, in *AddChallengeRequest, opts ...grpc.CallOption) (Daemon_AddChallengeClient, error)
	AddNotification(ctx context.Context, in *AddNotificationRequest, opts ...grpc.CallOption) (*AddNotificationResponse, error)
	DeleteTeam(ctx context.Context, in *DeleteTeamRequest, opts ...grpc.CallOption) (Daemon_DeleteTeamClient, error)
	GetTeamChals(ctx context.Context, in *GetTeamInfoRequest, opts ...grpc.CallOption) (*TeamChalsInfo, error)
	StressEvent(ctx context.Context, in *TestEventLoadReq, opts ...grpc.CallOption) (*TestEventLoadResp, error)
	ListExercises(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListExercisesResponse, error)
	ResetExercise(ctx context.Context, in *ResetExerciseRequest, opts ...grpc.CallOption) (Daemon_ResetExerciseClient, error)
	GetExercisesByTags(ctx context.Context, in *GetExsByTagsReq, opts ...grpc.CallOption) (*GetExsByTagsResp, error)
	ListFrontends(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListFrontendsResponse, error)
	ResetFrontends(ctx context.Context, in *ResetFrontendsRequest, opts ...grpc.CallOption) (Daemon_ResetFrontendsClient, error)
	SetFrontendMemory(ctx context.Context, in *SetFrontendMemoryRequest, opts ...grpc.CallOption) (*Empty, error)
	SetFrontendCpu(ctx context.Context, in *SetFrontendCpuRequest, opts ...grpc.CallOption) (*Empty, error)
	GetTeamInfo(ctx context.Context, in *GetTeamInfoRequest, opts ...grpc.CallOption) (*GetTeamInfoResponse, error)
	MonitorHost(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_MonitorHostClient, error)
	Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	ListCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCategoriesResponse, error)
	SaveProfile(ctx context.Context, in *SaveProfileRequest, opts ...grpc.CallOption) (Daemon_SaveProfileClient, error)
	DeleteProfile(ctx context.Context, in *DeleteProfileRequest, opts ...grpc.CallOption) (Daemon_DeleteProfileClient, error)
	EditProfile(ctx context.Context, in *SaveProfileRequest, opts ...grpc.CallOption) (Daemon_EditProfileClient, error)
	ListProfiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProfilesResponse, error)
}

type daemonClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonClient(cc grpc.ClientConnInterface) DaemonClient {
	return &daemonClient{cc}
}

func (c *daemonClient) LoginUser(ctx context.Context, in *LoginUserRequest, opts ...grpc.CallOption) (*LoginUserResponse, error) {
	out := new(LoginUserResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/LoginUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SignupUser(ctx context.Context, in *SignupUserRequest, opts ...grpc.CallOption) (*LoginUserResponse, error) {
	out := new(LoginUserResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/SignupUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) InviteUser(ctx context.Context, in *InviteUserRequest, opts ...grpc.CallOption) (*InviteUserResponse, error) {
	out := new(InviteUserResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/InviteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ListUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ListUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ChangeUserPasswd(ctx context.Context, in *UpdatePasswdRequest, opts ...grpc.CallOption) (*UpdatePasswdResponse, error) {
	out := new(UpdatePasswdResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ChangeUserPasswd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) DestroyUser(ctx context.Context, in *DestroyUserRequest, opts ...grpc.CallOption) (*DestroyUserResponse, error) {
	out := new(DestroyUserResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/DestroyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetTeamSuspend(ctx context.Context, in *SetTeamSuspendRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/SetTeamSuspend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) UpdateTeamPassword(ctx context.Context, in *UpdateTeamPassRequest, opts ...grpc.CallOption) (*UpdateTeamPassResponse, error) {
	out := new(UpdateTeamPassResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/UpdateTeamPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetAPICreds(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CredsResponse, error) {
	out := new(CredsResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/GetAPICreds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) CreateEvent(ctx context.Context, in *CreateEventRequest, opts ...grpc.CallOption) (Daemon_CreateEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[0], "/daemon.Daemon/CreateEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonCreateEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_CreateEventClient interface {
	Recv() (*LabStatus, error)
	grpc.ClientStream
}

type daemonCreateEventClient struct {
	grpc.ClientStream
}

func (x *daemonCreateEventClient) Recv() (*LabStatus, error) {
	m := new(LabStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) StopEvent(ctx context.Context, in *StopEventRequest, opts ...grpc.CallOption) (Daemon_StopEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[1], "/daemon.Daemon/StopEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonStopEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_StopEventClient interface {
	Recv() (*EventStatus, error)
	grpc.ClientStream
}

type daemonStopEventClient struct {
	grpc.ClientStream
}

func (x *daemonStopEventClient) Recv() (*EventStatus, error) {
	m := new(EventStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) SuspendEvent(ctx context.Context, in *SuspendEventRequest, opts ...grpc.CallOption) (Daemon_SuspendEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[2], "/daemon.Daemon/SuspendEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonSuspendEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_SuspendEventClient interface {
	Recv() (*EventStatus, error)
	grpc.ClientStream
}

type daemonSuspendEventClient struct {
	grpc.ClientStream
}

func (x *daemonSuspendEventClient) Recv() (*EventStatus, error) {
	m := new(EventStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) ListEvents(ctx context.Context, in *ListEventsRequest, opts ...grpc.CallOption) (*ListEventsResponse, error) {
	out := new(ListEventsResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ListEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ListEventTeams(ctx context.Context, in *ListEventTeamsRequest, opts ...grpc.CallOption) (*ListEventTeamsResponse, error) {
	out := new(ListEventTeamsResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ListEventTeams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) RestartTeamLab(ctx context.Context, in *RestartTeamLabRequest, opts ...grpc.CallOption) (Daemon_RestartTeamLabClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[3], "/daemon.Daemon/RestartTeamLab", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonRestartTeamLabClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_RestartTeamLabClient interface {
	Recv() (*EventStatus, error)
	grpc.ClientStream
}

type daemonRestartTeamLabClient struct {
	grpc.ClientStream
}

func (x *daemonRestartTeamLabClient) Recv() (*EventStatus, error) {
	m := new(EventStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) SolveChallenge(ctx context.Context, in *SolveChallengeRequest, opts ...grpc.CallOption) (*SolveChallengeResponse, error) {
	out := new(SolveChallengeResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/SolveChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) AddChallenge(ctx context.Context, in *AddChallengeRequest, opts ...grpc.CallOption) (Daemon_AddChallengeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[4], "/daemon.Daemon/AddChallenge", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonAddChallengeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_AddChallengeClient interface {
	Recv() (*AddChallengeResponse, error)
	grpc.ClientStream
}

type daemonAddChallengeClient struct {
	grpc.ClientStream
}

func (x *daemonAddChallengeClient) Recv() (*AddChallengeResponse, error) {
	m := new(AddChallengeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) AddNotification(ctx context.Context, in *AddNotificationRequest, opts ...grpc.CallOption) (*AddNotificationResponse, error) {
	out := new(AddNotificationResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/AddNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) DeleteTeam(ctx context.Context, in *DeleteTeamRequest, opts ...grpc.CallOption) (Daemon_DeleteTeamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[5], "/daemon.Daemon/DeleteTeam", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonDeleteTeamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_DeleteTeamClient interface {
	Recv() (*DeleteTeamResponse, error)
	grpc.ClientStream
}

type daemonDeleteTeamClient struct {
	grpc.ClientStream
}

func (x *daemonDeleteTeamClient) Recv() (*DeleteTeamResponse, error) {
	m := new(DeleteTeamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) GetTeamChals(ctx context.Context, in *GetTeamInfoRequest, opts ...grpc.CallOption) (*TeamChalsInfo, error) {
	out := new(TeamChalsInfo)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/GetTeamChals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) StressEvent(ctx context.Context, in *TestEventLoadReq, opts ...grpc.CallOption) (*TestEventLoadResp, error) {
	out := new(TestEventLoadResp)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/StressEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ListExercises(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListExercisesResponse, error) {
	out := new(ListExercisesResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ListExercises", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ResetExercise(ctx context.Context, in *ResetExerciseRequest, opts ...grpc.CallOption) (Daemon_ResetExerciseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[6], "/daemon.Daemon/ResetExercise", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonResetExerciseClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_ResetExerciseClient interface {
	Recv() (*ResetTeamStatus, error)
	grpc.ClientStream
}

type daemonResetExerciseClient struct {
	grpc.ClientStream
}

func (x *daemonResetExerciseClient) Recv() (*ResetTeamStatus, error) {
	m := new(ResetTeamStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) GetExercisesByTags(ctx context.Context, in *GetExsByTagsReq, opts ...grpc.CallOption) (*GetExsByTagsResp, error) {
	out := new(GetExsByTagsResp)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/GetExercisesByTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ListFrontends(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListFrontendsResponse, error) {
	out := new(ListFrontendsResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ListFrontends", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ResetFrontends(ctx context.Context, in *ResetFrontendsRequest, opts ...grpc.CallOption) (Daemon_ResetFrontendsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[7], "/daemon.Daemon/ResetFrontends", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonResetFrontendsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_ResetFrontendsClient interface {
	Recv() (*ResetTeamStatus, error)
	grpc.ClientStream
}

type daemonResetFrontendsClient struct {
	grpc.ClientStream
}

func (x *daemonResetFrontendsClient) Recv() (*ResetTeamStatus, error) {
	m := new(ResetTeamStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) SetFrontendMemory(ctx context.Context, in *SetFrontendMemoryRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/SetFrontendMemory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetFrontendCpu(ctx context.Context, in *SetFrontendCpuRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/SetFrontendCpu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) GetTeamInfo(ctx context.Context, in *GetTeamInfoRequest, opts ...grpc.CallOption) (*GetTeamInfoResponse, error) {
	out := new(GetTeamInfoResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/GetTeamInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) MonitorHost(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Daemon_MonitorHostClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[8], "/daemon.Daemon/MonitorHost", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonMonitorHostClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_MonitorHostClient interface {
	Recv() (*MonitorHostResponse, error)
	grpc.ClientStream
}

type daemonMonitorHostClient struct {
	grpc.ClientStream
}

func (x *daemonMonitorHostClient) Recv() (*MonitorHostResponse, error) {
	m := new(MonitorHostResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) Version(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) ListCategories(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListCategoriesResponse, error) {
	out := new(ListCategoriesResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ListCategories", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SaveProfile(ctx context.Context, in *SaveProfileRequest, opts ...grpc.CallOption) (Daemon_SaveProfileClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[9], "/daemon.Daemon/SaveProfile", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonSaveProfileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_SaveProfileClient interface {
	Recv() (*ProfileStatus, error)
	grpc.ClientStream
}

type daemonSaveProfileClient struct {
	grpc.ClientStream
}

func (x *daemonSaveProfileClient) Recv() (*ProfileStatus, error) {
	m := new(ProfileStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) DeleteProfile(ctx context.Context, in *DeleteProfileRequest, opts ...grpc.CallOption) (Daemon_DeleteProfileClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[10], "/daemon.Daemon/DeleteProfile", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonDeleteProfileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_DeleteProfileClient interface {
	Recv() (*ProfileStatus, error)
	grpc.ClientStream
}

type daemonDeleteProfileClient struct {
	grpc.ClientStream
}

func (x *daemonDeleteProfileClient) Recv() (*ProfileStatus, error) {
	m := new(ProfileStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) EditProfile(ctx context.Context, in *SaveProfileRequest, opts ...grpc.CallOption) (Daemon_EditProfileClient, error) {
	stream, err := c.cc.NewStream(ctx, &Daemon_ServiceDesc.Streams[11], "/daemon.Daemon/EditProfile", opts...)
	if err != nil {
		return nil, err
	}
	x := &daemonEditProfileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Daemon_EditProfileClient interface {
	Recv() (*ProfileStatus, error)
	grpc.ClientStream
}

type daemonEditProfileClient struct {
	grpc.ClientStream
}

func (x *daemonEditProfileClient) Recv() (*ProfileStatus, error) {
	m := new(ProfileStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *daemonClient) ListProfiles(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListProfilesResponse, error) {
	out := new(ListProfilesResponse)
	err := c.cc.Invoke(ctx, "/daemon.Daemon/ListProfiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonServer is the server API for Daemon service.
// All implementations must embed UnimplementedDaemonServer
// for forward compatibility
type DaemonServer interface {
	LoginUser(context.Context, *LoginUserRequest) (*LoginUserResponse, error)
	SignupUser(context.Context, *SignupUserRequest) (*LoginUserResponse, error)
	InviteUser(context.Context, *InviteUserRequest) (*InviteUserResponse, error)
	ListUsers(context.Context, *Empty) (*ListUsersResponse, error)
	ChangeUserPasswd(context.Context, *UpdatePasswdRequest) (*UpdatePasswdResponse, error)
	DestroyUser(context.Context, *DestroyUserRequest) (*DestroyUserResponse, error)
	SetTeamSuspend(context.Context, *SetTeamSuspendRequest) (*Empty, error)
	UpdateTeamPassword(context.Context, *UpdateTeamPassRequest) (*UpdateTeamPassResponse, error)
	GetAPICreds(context.Context, *Empty) (*CredsResponse, error)
	CreateEvent(*CreateEventRequest, Daemon_CreateEventServer) error
	StopEvent(*StopEventRequest, Daemon_StopEventServer) error
	SuspendEvent(*SuspendEventRequest, Daemon_SuspendEventServer) error
	ListEvents(context.Context, *ListEventsRequest) (*ListEventsResponse, error)
	ListEventTeams(context.Context, *ListEventTeamsRequest) (*ListEventTeamsResponse, error)
	RestartTeamLab(*RestartTeamLabRequest, Daemon_RestartTeamLabServer) error
	SolveChallenge(context.Context, *SolveChallengeRequest) (*SolveChallengeResponse, error)
	AddChallenge(*AddChallengeRequest, Daemon_AddChallengeServer) error
	AddNotification(context.Context, *AddNotificationRequest) (*AddNotificationResponse, error)
	DeleteTeam(*DeleteTeamRequest, Daemon_DeleteTeamServer) error
	GetTeamChals(context.Context, *GetTeamInfoRequest) (*TeamChalsInfo, error)
	StressEvent(context.Context, *TestEventLoadReq) (*TestEventLoadResp, error)
	ListExercises(context.Context, *Empty) (*ListExercisesResponse, error)
	ResetExercise(*ResetExerciseRequest, Daemon_ResetExerciseServer) error
	GetExercisesByTags(context.Context, *GetExsByTagsReq) (*GetExsByTagsResp, error)
	ListFrontends(context.Context, *Empty) (*ListFrontendsResponse, error)
	ResetFrontends(*ResetFrontendsRequest, Daemon_ResetFrontendsServer) error
	SetFrontendMemory(context.Context, *SetFrontendMemoryRequest) (*Empty, error)
	SetFrontendCpu(context.Context, *SetFrontendCpuRequest) (*Empty, error)
	GetTeamInfo(context.Context, *GetTeamInfoRequest) (*GetTeamInfoResponse, error)
	MonitorHost(*Empty, Daemon_MonitorHostServer) error
	Version(context.Context, *Empty) (*VersionResponse, error)
	ListCategories(context.Context, *Empty) (*ListCategoriesResponse, error)
	SaveProfile(*SaveProfileRequest, Daemon_SaveProfileServer) error
	DeleteProfile(*DeleteProfileRequest, Daemon_DeleteProfileServer) error
	EditProfile(*SaveProfileRequest, Daemon_EditProfileServer) error
	ListProfiles(context.Context, *Empty) (*ListProfilesResponse, error)
	mustEmbedUnimplementedDaemonServer()
}

// UnimplementedDaemonServer must be embedded to have forward compatible implementations.
type UnimplementedDaemonServer struct {
}

func (UnimplementedDaemonServer) LoginUser(context.Context, *LoginUserRequest) (*LoginUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginUser not implemented")
}
func (UnimplementedDaemonServer) SignupUser(context.Context, *SignupUserRequest) (*LoginUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignupUser not implemented")
}
func (UnimplementedDaemonServer) InviteUser(context.Context, *InviteUserRequest) (*InviteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteUser not implemented")
}
func (UnimplementedDaemonServer) ListUsers(context.Context, *Empty) (*ListUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedDaemonServer) ChangeUserPasswd(context.Context, *UpdatePasswdRequest) (*UpdatePasswdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeUserPasswd not implemented")
}
func (UnimplementedDaemonServer) DestroyUser(context.Context, *DestroyUserRequest) (*DestroyUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyUser not implemented")
}
func (UnimplementedDaemonServer) SetTeamSuspend(context.Context, *SetTeamSuspendRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTeamSuspend not implemented")
}
func (UnimplementedDaemonServer) UpdateTeamPassword(context.Context, *UpdateTeamPassRequest) (*UpdateTeamPassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTeamPassword not implemented")
}
func (UnimplementedDaemonServer) GetAPICreds(context.Context, *Empty) (*CredsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPICreds not implemented")
}
func (UnimplementedDaemonServer) CreateEvent(*CreateEventRequest, Daemon_CreateEventServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateEvent not implemented")
}
func (UnimplementedDaemonServer) StopEvent(*StopEventRequest, Daemon_StopEventServer) error {
	return status.Errorf(codes.Unimplemented, "method StopEvent not implemented")
}
func (UnimplementedDaemonServer) SuspendEvent(*SuspendEventRequest, Daemon_SuspendEventServer) error {
	return status.Errorf(codes.Unimplemented, "method SuspendEvent not implemented")
}
func (UnimplementedDaemonServer) ListEvents(context.Context, *ListEventsRequest) (*ListEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedDaemonServer) ListEventTeams(context.Context, *ListEventTeamsRequest) (*ListEventTeamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEventTeams not implemented")
}
func (UnimplementedDaemonServer) RestartTeamLab(*RestartTeamLabRequest, Daemon_RestartTeamLabServer) error {
	return status.Errorf(codes.Unimplemented, "method RestartTeamLab not implemented")
}
func (UnimplementedDaemonServer) SolveChallenge(context.Context, *SolveChallengeRequest) (*SolveChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SolveChallenge not implemented")
}
func (UnimplementedDaemonServer) AddChallenge(*AddChallengeRequest, Daemon_AddChallengeServer) error {
	return status.Errorf(codes.Unimplemented, "method AddChallenge not implemented")
}
func (UnimplementedDaemonServer) AddNotification(context.Context, *AddNotificationRequest) (*AddNotificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNotification not implemented")
}
func (UnimplementedDaemonServer) DeleteTeam(*DeleteTeamRequest, Daemon_DeleteTeamServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteTeam not implemented")
}
func (UnimplementedDaemonServer) GetTeamChals(context.Context, *GetTeamInfoRequest) (*TeamChalsInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeamChals not implemented")
}
func (UnimplementedDaemonServer) StressEvent(context.Context, *TestEventLoadReq) (*TestEventLoadResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StressEvent not implemented")
}
func (UnimplementedDaemonServer) ListExercises(context.Context, *Empty) (*ListExercisesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExercises not implemented")
}
func (UnimplementedDaemonServer) ResetExercise(*ResetExerciseRequest, Daemon_ResetExerciseServer) error {
	return status.Errorf(codes.Unimplemented, "method ResetExercise not implemented")
}
func (UnimplementedDaemonServer) GetExercisesByTags(context.Context, *GetExsByTagsReq) (*GetExsByTagsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExercisesByTags not implemented")
}
func (UnimplementedDaemonServer) ListFrontends(context.Context, *Empty) (*ListFrontendsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFrontends not implemented")
}
func (UnimplementedDaemonServer) ResetFrontends(*ResetFrontendsRequest, Daemon_ResetFrontendsServer) error {
	return status.Errorf(codes.Unimplemented, "method ResetFrontends not implemented")
}
func (UnimplementedDaemonServer) SetFrontendMemory(context.Context, *SetFrontendMemoryRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFrontendMemory not implemented")
}
func (UnimplementedDaemonServer) SetFrontendCpu(context.Context, *SetFrontendCpuRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFrontendCpu not implemented")
}
func (UnimplementedDaemonServer) GetTeamInfo(context.Context, *GetTeamInfoRequest) (*GetTeamInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeamInfo not implemented")
}
func (UnimplementedDaemonServer) MonitorHost(*Empty, Daemon_MonitorHostServer) error {
	return status.Errorf(codes.Unimplemented, "method MonitorHost not implemented")
}
func (UnimplementedDaemonServer) Version(context.Context, *Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedDaemonServer) ListCategories(context.Context, *Empty) (*ListCategoriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCategories not implemented")
}
func (UnimplementedDaemonServer) SaveProfile(*SaveProfileRequest, Daemon_SaveProfileServer) error {
	return status.Errorf(codes.Unimplemented, "method SaveProfile not implemented")
}
func (UnimplementedDaemonServer) DeleteProfile(*DeleteProfileRequest, Daemon_DeleteProfileServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteProfile not implemented")
}
func (UnimplementedDaemonServer) EditProfile(*SaveProfileRequest, Daemon_EditProfileServer) error {
	return status.Errorf(codes.Unimplemented, "method EditProfile not implemented")
}
func (UnimplementedDaemonServer) ListProfiles(context.Context, *Empty) (*ListProfilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProfiles not implemented")
}
func (UnimplementedDaemonServer) mustEmbedUnimplementedDaemonServer() {}

// UnsafeDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonServer will
// result in compilation errors.
type UnsafeDaemonServer interface {
	mustEmbedUnimplementedDaemonServer()
}

func RegisterDaemonServer(s grpc.ServiceRegistrar, srv DaemonServer) {
	s.RegisterService(&Daemon_ServiceDesc, srv)
}

func _Daemon_LoginUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/LoginUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginUser(ctx, req.(*LoginUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SignupUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignupUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SignupUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/SignupUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SignupUser(ctx, req.(*SignupUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_InviteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InviteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).InviteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/InviteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).InviteUser(ctx, req.(*InviteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListUsers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ChangeUserPasswd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePasswdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ChangeUserPasswd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ChangeUserPasswd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ChangeUserPasswd(ctx, req.(*UpdatePasswdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_DestroyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).DestroyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/DestroyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).DestroyUser(ctx, req.(*DestroyUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetTeamSuspend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTeamSuspendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetTeamSuspend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/SetTeamSuspend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetTeamSuspend(ctx, req.(*SetTeamSuspendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_UpdateTeamPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamPassRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).UpdateTeamPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/UpdateTeamPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).UpdateTeamPassword(ctx, req.(*UpdateTeamPassRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetAPICreds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetAPICreds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/GetAPICreds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetAPICreds(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_CreateEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CreateEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).CreateEvent(m, &daemonCreateEventServer{stream})
}

type Daemon_CreateEventServer interface {
	Send(*LabStatus) error
	grpc.ServerStream
}

type daemonCreateEventServer struct {
	grpc.ServerStream
}

func (x *daemonCreateEventServer) Send(m *LabStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_StopEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StopEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).StopEvent(m, &daemonStopEventServer{stream})
}

type Daemon_StopEventServer interface {
	Send(*EventStatus) error
	grpc.ServerStream
}

type daemonStopEventServer struct {
	grpc.ServerStream
}

func (x *daemonStopEventServer) Send(m *EventStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_SuspendEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SuspendEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).SuspendEvent(m, &daemonSuspendEventServer{stream})
}

type Daemon_SuspendEventServer interface {
	Send(*EventStatus) error
	grpc.ServerStream
}

type daemonSuspendEventServer struct {
	grpc.ServerStream
}

func (x *daemonSuspendEventServer) Send(m *EventStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ListEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListEvents(ctx, req.(*ListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ListEventTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEventTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListEventTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ListEventTeams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListEventTeams(ctx, req.(*ListEventTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_RestartTeamLab_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RestartTeamLabRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).RestartTeamLab(m, &daemonRestartTeamLabServer{stream})
}

type Daemon_RestartTeamLabServer interface {
	Send(*EventStatus) error
	grpc.ServerStream
}

type daemonRestartTeamLabServer struct {
	grpc.ServerStream
}

func (x *daemonRestartTeamLabServer) Send(m *EventStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_SolveChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolveChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SolveChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/SolveChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SolveChallenge(ctx, req.(*SolveChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_AddChallenge_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AddChallengeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).AddChallenge(m, &daemonAddChallengeServer{stream})
}

type Daemon_AddChallengeServer interface {
	Send(*AddChallengeResponse) error
	grpc.ServerStream
}

type daemonAddChallengeServer struct {
	grpc.ServerStream
}

func (x *daemonAddChallengeServer) Send(m *AddChallengeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_AddNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).AddNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/AddNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).AddNotification(ctx, req.(*AddNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_DeleteTeam_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeleteTeamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).DeleteTeam(m, &daemonDeleteTeamServer{stream})
}

type Daemon_DeleteTeamServer interface {
	Send(*DeleteTeamResponse) error
	grpc.ServerStream
}

type daemonDeleteTeamServer struct {
	grpc.ServerStream
}

func (x *daemonDeleteTeamServer) Send(m *DeleteTeamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_GetTeamChals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetTeamChals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/GetTeamChals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetTeamChals(ctx, req.(*GetTeamInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_StressEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestEventLoadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).StressEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/StressEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).StressEvent(ctx, req.(*TestEventLoadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ListExercises_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListExercises(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ListExercises",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListExercises(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ResetExercise_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ResetExerciseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).ResetExercise(m, &daemonResetExerciseServer{stream})
}

type Daemon_ResetExerciseServer interface {
	Send(*ResetTeamStatus) error
	grpc.ServerStream
}

type daemonResetExerciseServer struct {
	grpc.ServerStream
}

func (x *daemonResetExerciseServer) Send(m *ResetTeamStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_GetExercisesByTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExsByTagsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetExercisesByTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/GetExercisesByTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetExercisesByTags(ctx, req.(*GetExsByTagsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ListFrontends_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListFrontends(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ListFrontends",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListFrontends(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ResetFrontends_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ResetFrontendsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).ResetFrontends(m, &daemonResetFrontendsServer{stream})
}

type Daemon_ResetFrontendsServer interface {
	Send(*ResetTeamStatus) error
	grpc.ServerStream
}

type daemonResetFrontendsServer struct {
	grpc.ServerStream
}

func (x *daemonResetFrontendsServer) Send(m *ResetTeamStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_SetFrontendMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFrontendMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetFrontendMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/SetFrontendMemory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetFrontendMemory(ctx, req.(*SetFrontendMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetFrontendCpu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFrontendCpuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetFrontendCpu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/SetFrontendCpu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetFrontendCpu(ctx, req.(*SetFrontendCpuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_GetTeamInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).GetTeamInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/GetTeamInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).GetTeamInfo(ctx, req.(*GetTeamInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_MonitorHost_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).MonitorHost(m, &daemonMonitorHostServer{stream})
}

type Daemon_MonitorHostServer interface {
	Send(*MonitorHostResponse) error
	grpc.ServerStream
}

type daemonMonitorHostServer struct {
	grpc.ServerStream
}

func (x *daemonMonitorHostServer) Send(m *MonitorHostResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Version(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_ListCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ListCategories",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListCategories(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SaveProfile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SaveProfileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).SaveProfile(m, &daemonSaveProfileServer{stream})
}

type Daemon_SaveProfileServer interface {
	Send(*ProfileStatus) error
	grpc.ServerStream
}

type daemonSaveProfileServer struct {
	grpc.ServerStream
}

func (x *daemonSaveProfileServer) Send(m *ProfileStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_DeleteProfile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeleteProfileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).DeleteProfile(m, &daemonDeleteProfileServer{stream})
}

type Daemon_DeleteProfileServer interface {
	Send(*ProfileStatus) error
	grpc.ServerStream
}

type daemonDeleteProfileServer struct {
	grpc.ServerStream
}

func (x *daemonDeleteProfileServer) Send(m *ProfileStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_EditProfile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SaveProfileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServer).EditProfile(m, &daemonEditProfileServer{stream})
}

type Daemon_EditProfileServer interface {
	Send(*ProfileStatus) error
	grpc.ServerStream
}

type daemonEditProfileServer struct {
	grpc.ServerStream
}

func (x *daemonEditProfileServer) Send(m *ProfileStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _Daemon_ListProfiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).ListProfiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/daemon.Daemon/ListProfiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).ListProfiles(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Daemon_ServiceDesc is the grpc.ServiceDesc for Daemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Daemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.Daemon",
	HandlerType: (*DaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoginUser",
			Handler:    _Daemon_LoginUser_Handler,
		},
		{
			MethodName: "SignupUser",
			Handler:    _Daemon_SignupUser_Handler,
		},
		{
			MethodName: "InviteUser",
			Handler:    _Daemon_InviteUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _Daemon_ListUsers_Handler,
		},
		{
			MethodName: "ChangeUserPasswd",
			Handler:    _Daemon_ChangeUserPasswd_Handler,
		},
		{
			MethodName: "DestroyUser",
			Handler:    _Daemon_DestroyUser_Handler,
		},
		{
			MethodName: "SetTeamSuspend",
			Handler:    _Daemon_SetTeamSuspend_Handler,
		},
		{
			MethodName: "UpdateTeamPassword",
			Handler:    _Daemon_UpdateTeamPassword_Handler,
		},
		{
			MethodName: "GetAPICreds",
			Handler:    _Daemon_GetAPICreds_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _Daemon_ListEvents_Handler,
		},
		{
			MethodName: "ListEventTeams",
			Handler:    _Daemon_ListEventTeams_Handler,
		},
		{
			MethodName: "SolveChallenge",
			Handler:    _Daemon_SolveChallenge_Handler,
		},
		{
			MethodName: "AddNotification",
			Handler:    _Daemon_AddNotification_Handler,
		},
		{
			MethodName: "GetTeamChals",
			Handler:    _Daemon_GetTeamChals_Handler,
		},
		{
			MethodName: "StressEvent",
			Handler:    _Daemon_StressEvent_Handler,
		},
		{
			MethodName: "ListExercises",
			Handler:    _Daemon_ListExercises_Handler,
		},
		{
			MethodName: "GetExercisesByTags",
			Handler:    _Daemon_GetExercisesByTags_Handler,
		},
		{
			MethodName: "ListFrontends",
			Handler:    _Daemon_ListFrontends_Handler,
		},
		{
			MethodName: "SetFrontendMemory",
			Handler:    _Daemon_SetFrontendMemory_Handler,
		},
		{
			MethodName: "SetFrontendCpu",
			Handler:    _Daemon_SetFrontendCpu_Handler,
		},
		{
			MethodName: "GetTeamInfo",
			Handler:    _Daemon_GetTeamInfo_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _Daemon_Version_Handler,
		},
		{
			MethodName: "ListCategories",
			Handler:    _Daemon_ListCategories_Handler,
		},
		{
			MethodName: "ListProfiles",
			Handler:    _Daemon_ListProfiles_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateEvent",
			Handler:       _Daemon_CreateEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StopEvent",
			Handler:       _Daemon_StopEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SuspendEvent",
			Handler:       _Daemon_SuspendEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RestartTeamLab",
			Handler:       _Daemon_RestartTeamLab_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AddChallenge",
			Handler:       _Daemon_AddChallenge_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteTeam",
			Handler:       _Daemon_DeleteTeam_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ResetExercise",
			Handler:       _Daemon_ResetExercise_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ResetFrontends",
			Handler:       _Daemon_ResetFrontends_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MonitorHost",
			Handler:       _Daemon_MonitorHost_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SaveProfile",
			Handler:       _Daemon_SaveProfile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DeleteProfile",
			Handler:       _Daemon_DeleteProfile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EditProfile",
			Handler:       _Daemon_EditProfile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "daemon.proto",
}
